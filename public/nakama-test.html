<!DOCTYPE html>
<html>
<head>
  <title>Nakama Server Test</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
      background: #1e1e1e;
      color: #d4d4d4;
    }
    .test {
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #444;
      border-radius: 8px;
      background: #252526;
    }
    .success { border-left: 4px solid #4caf50; }
    .error { border-left: 4px solid #f44336; }
    .pending { border-left: 4px solid #ff9800; }
    h2 { color: #61dafb; }
    pre {
      background: #1e1e1e;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    button {
      background: #61dafb;
      color: #1e1e1e;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      margin: 5px;
    }
    button:hover {
      background: #4fa3c1;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <h1>ðŸ§ª Nakama Server Test</h1>
  
  <div>
    <button id="runTestsBtn" onclick="runAllTests()">Run All Tests</button>
    <button id="resetBtn" onclick="resetTests()">Reset Tests</button>
  </div>
  
  <div id="test-1" class="test pending">
    <h2>Test 1: Server Reachable</h2>
    <p>Testing HTTP connection to Nakama server...</p>
    <pre id="result-1">Waiting...</pre>
  </div>
  
  <div id="test-2" class="test pending">
    <h2>Test 2: Client Library</h2>
    <p>Checking if Nakama JS client is loaded...</p>
    <pre id="result-2">Waiting...</pre>
  </div>
  
  <div id="test-3" class="test pending">
    <h2>Test 3: Device Authentication</h2>
    <p>Testing device authentication...</p>
    <pre id="result-3">Waiting...</pre>
  </div>
  
  <div id="test-4" class="test pending">
    <h2>Test 4: Socket Connection</h2>
    <p>Testing WebSocket connection...</p>
    <pre id="result-4">Waiting...</pre>
  </div>

  <!-- Nakama client library -->
  <script src="https://cdn.jsdelivr.net/npm/@heroiclabs/nakama-js@2.6.0/dist/sdk/nakama-js.umd.min.js"></script>
  
  <script>
    // Nakama server configuration
    const NAKAMA_SERVER_KEY = 'defaultkey';
    const NAKAMA_HOST = 'localhost';
    const NAKAMA_PORT = '7350';
    const NAKAMA_USE_SSL = false;
    
    // Create a new Nakama client
    let client = null;
    let socket = null;
    
    // Initialize the Nakama client
    function initClient() {
      try {
        client = new nakamajs.Client(
          NAKAMA_SERVER_KEY,
          NAKAMA_HOST,
          NAKAMA_PORT,
          NAKAMA_USE_SSL
        );
        console.log('Nakama client initialized');
        return true;
      } catch (error) {
        console.error('Failed to initialize Nakama client:', error);
        return false;
      }
    }
    
    // Helper function to set test results
    function setResult(testNum, status, message) {
      const testDiv = document.getElementById(`test-${testNum}`);
      const resultPre = document.getElementById(`result-${testNum}`);
      
      testDiv.className = `test ${status}`;
      resultPre.textContent = message;
      console.log(`Test ${testNum} (${status}):`, message);
    }
    
    // Test 1: Check if server is reachable
    async function test1ServerReachable() {
      try {
        const response = await fetch(`http${NAKAMA_USE_SSL ? 's' : ''}://${NAKAMA_HOST}:${NAKAMA_PORT}/v2/console/config`, {
          method: 'GET',
          headers: { 'Accept': 'application/json' }
        });
        
        if (response.ok) {
          const data = await response.json();
          setResult(1, 'success', 
            `âœ… Server is reachable!\n\nNakama Version: ${data.version || 'Unknown'}\nServer Time: ${new Date().toISOString()}`
          );
          return true;
        } else {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
      } catch (error) {
        setResult(1, 'error', 
          `âŒ Server is not reachable!\n\nError: ${error.message}\n\nMake sure Nakama server is running on ${NAKAMA_HOST}:${NAKAMA_PORT}`
        );
        return false;
      }
    }
    
    // Test 2: Check if client library is loaded
    function test2ClientLibrary() {
      try {
        if (typeof nakamajs === 'undefined' || !nakamajs.Client) {
          throw new Error('Nakama client library not loaded');
        }
        
        const clientOk = initClient();
        if (!clientOk) {
          throw new Error('Failed to initialize Nakama client');
        }
        
        setResult(2, 'success', 
          `âœ… Nakama JS client loaded successfully!\n\nVersion: ${nakamajs.VERSION || 'Unknown'}`
        );
        return true;
      } catch (error) {
        setResult(2, 'error', 
          `âŒ Failed to load Nakama client library!\n\nError: ${error.message}\n\nMake sure the Nakama JS client is properly included.`
        );
        return false;
      }
    }
    
    // Test 3: Test device authentication
    async function test3Authentication() {
      if (!client) {
        setResult(3, 'error', 'âŒ Client not initialized. Run Test 2 first.');
        return null;
      }
      
      try {
        // Generate a random device ID or use a stored one
        let deviceId = localStorage.getItem('nakama_device_id');
        if (!deviceId) {
          deviceId = 'device_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('nakama_device_id', deviceId);
        }
        
        // Generate a random username
        const username = 'user_' + Math.random().toString(36).substr(2, 8);
        
        // Authenticate with the device ID
        const session = await client.authenticateDevice(deviceId, true, username);
        
        if (session) {
          setResult(3, 'success', 
            `âœ… Authentication successful!\n\nUser ID: ${session.user_id}\nUsername: ${session.username}\nToken: ${session.token ? session.token.substring(0, 20) + '...' : 'No token'}`
          );
          return { client, session };
        } else {
          throw new Error('Authentication returned no session');
        }
      } catch (error) {
        setResult(3, 'error', 
          `âŒ Authentication failed!\n\nError: ${error.message || 'Unknown error'}\nStatus: ${error.status || 'N/A'}`
        );
        return null;
      }
    }
    
    // Test 4: Test socket connection
    async function test4SocketConnection(authResult) {
      if (!authResult || !authResult.client || !authResult.session) {
        setResult(4, 'error', 'âŒ Skipped (no valid session or client from test 3)');
        return false;
      }
      
      const { client, session } = authResult;
      
      try {
        // Create a new socket connection
        socket = client.createSocket(NAKAMA_USE_SSL);
        
        // Set up connection state change handler
        socket.ondisconnect = (event) => {
          console.log('Socket disconnected:', event);
        };
        
        // Connect the socket
        await socket.connect(session, true);
        
        setResult(4, 'success', 
          `âœ… Socket connected successfully!\n\nSocket ID: ${socket.id || 'N/A'}\nSession ID: ${session.session_id || 'N/A'}`
        );
        
        // Disconnect after a short delay
        setTimeout(() => {
          if (socket) socket.disconnect();
        }, 1000);
        
        return true;
      } catch (error) {
        setResult(4, 'error', 
          `âŒ Socket connection failed!\n\nError: ${error.message || 'Unknown error'}\n\nCheck if WebSockets are enabled and not blocked by your browser.`
        );
        return false;
      } finally {
        // Clean up
        if (socket && socket.connected) {
          socket.disconnect();
        }
      }
    }
    
    // Run all tests
    async function runAllTests() {
      console.log('Starting Nakama server tests...');
      
      // Disable the run button while tests are running
      const runBtn = document.getElementById('runTestsBtn');
      runBtn.disabled = true;
      runBtn.textContent = 'Running Tests...';
      
      try {
        // Test 1: Server reachable
        const serverOk = await test1ServerReachable();
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Test 2: Client library
        const clientOk = test2ClientLibrary();
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Test 3: Authentication
        let authResult = null;
        if (serverOk && clientOk) {
          authResult = await test3Authentication();
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // Test 4: Socket connection
        if (authResult && authResult.session) {
          await test4SocketConnection(authResult);
        }
      } catch (error) {
        console.error('Error running tests:', error);
      } finally {
        // Re-enable the run button
        runBtn.disabled = false;
        runBtn.textContent = 'Run All Tests';
        console.log('Tests completed!');
      }
    }
    
    // Reset all tests
    function resetTests() {
      [1, 2, 3, 4].forEach(testNum => {
        const testDiv = document.getElementById(`test-${testNum}`);
        const resultPre = document.getElementById(`result-${testNum}`);
        testDiv.className = 'test pending';
        resultPre.textContent = 'Waiting...';
      });
      console.log('Tests have been reset');
    }
    
    // Auto-run tests when the page loads
    window.addEventListener('load', () => {
      console.log('Page loaded. Click "Run All Tests" to begin.');
    });
  </script>
</body>
</html>