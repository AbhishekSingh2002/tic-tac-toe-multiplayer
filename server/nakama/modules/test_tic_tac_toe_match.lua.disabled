-- test_tic_tac_toe_match.lua
local nk = require("nakama")
local match = require("game_logic.tic_tac_toe")

-- Mock Nakama context and dispatcher
local function create_mock_context(user_id)
    return {
        user_id = user_id or "test_user",
        username = "test_user",
        session_id = "session_" .. (user_id or "1"),
        user_session_exp = os.time() + 3600,
        match_id = "test_match_123",
        match_node = "test_node",
        match_label = "test_label",
        match_tick_rate = 10,
        match_loop = function() end
    }
end

local mock_dispatcher = {
    broadcast_messages = {},
    
    broadcast_message = function(self, opcode, data, presences, sender)
        table.insert(self.broadcast_messages, {
            opcode = opcode,
            data = data,
            presences = presences,
            sender = sender
        })
        print(string.format("üì¢ Broadcast (op %d): %s", opcode, data))
    end,
    
    match_label_update = function(label)
        print("üè∑Ô∏è  Match label updated:", label)
    end,
    
    clear = function(self)
        self.broadcast_messages = {}
    end,
    
    get_last_broadcast = function(self)
        return self.broadcast_messages[#self.broadcast_messages]
    end
}

-- Helper function to create a test presence
local function create_presence(user_id, username)
    return {
        user_id = user_id,
        session_id = "session_" .. user_id,
        username = username or ("user_%s"):format(user_id),
        node = "test_node"
    }
end

-- Helper function to simulate a move
local function make_move(state, dispatcher, tick, player_id, position)
    local message = {
        sender = create_presence(player_id),
        op_code = 1,
        data = nk.json_encode({
            type = "move",
            position = position
        })
    }
    return match.match_loop(
        create_mock_context(player_id),
        dispatcher,
        tick or 1,
        state,
        {message}
    )
end

-- Helper function to print the board
local function print_board(board)
    print("  " .. (board[1] or " ") .. " | " .. (board[2] or " ") .. " | " .. (board[3] or " ") .. "  ")
    print(" -----------")
    print("  " .. (board[4] or " ") .. " | " .. (board[5] or " ") .. " | " .. (board[6] or " ") .. "  ")
    print(" -----------")
    print("  " .. (board[7] or " ") .. " | " .. (board[8] or " ") .. " | " .. (board[9] or " ") .. "  ")
end

-- Helper function to assert with message
local function assert_equal(actual, expected, message)
    if actual ~= expected then
        error(string.format("%s\nExpected: %s\nActual: %s", message, tostring(expected), tostring(actual)))
    end
end

-- Test 1: Initialize a new match
print("\n=== Test 1: Initialize a new match ===")
local state, tick_rate, label = match.match_init(create_mock_context(), {
    match_id = "test_match_123",
    player_x_id = "player1",
    player_o_id = "player2"
})

print("Initial state:")
print("Match ID:\t", state.match_id)
print("Player X:\t", state.player_x_id)
print("Player O:\t", state.player_o_id)
print("Tick rate:\t", tick_rate)
print("Label:\t", label)

-- Test 2: Player join attempt
print("\n=== Test 2: Player join attempt ===")
local presence1 = create_presence("player1", "Player 1")
local presence2 = create_presence("player2", "Player 2")
local presence3 = create_presence("player3", "Player 3") -- Unauthorized player

-- Player 1 joins
local success, reject_reason = match.match_join_attempt(
    create_mock_context("player1"), 
    mock_dispatcher, 
    1, 
    state, 
    presence1, 
    {}
)
print("Player 1 join attempt:", success, reject_reason or "")
assert_equal(success, true, "Player 1 should be allowed to join")

-- Player 2 joins
success, reject_reason = match.match_join_attempt(
    create_mock_context("player2"), 
    mock_dispatcher, 
    2, 
    state, 
    presence2, 
    {}
)
print("Player 2 join attempt:", success, reject_reason or "")
assert_equal(success, true, "Player 2 should be allowed to join")

-- Unauthorized player tries to join
success, reject_reason = match.match_join_attempt(
    create_mock_context("player3"), 
    mock_dispatcher, 
    3, 
    state, 
    presence3, 
    {}
)
print("Player 3 (unauthorized) join attempt:", success, reject_reason or "")
assert_equal(success, false, "Player 3 should not be allowed to join")

-- Test 3: Player join notifications
print("\n=== Test 3: Player join notifications ===")
mock_dispatcher:clear()
state = match.match_join(
    create_mock_context(), 
    mock_dispatcher, 
    4, 
    state, 
    {presence1}
)
print("Player 1 joined")

-- Verify the broadcast message
local last_broadcast = mock_dispatcher:get_last_broadcast()
local message_data = nk.json_decode(last_broadcast.data)
print("Broadcast message type:", message_data.type)
assert_equal(message_data.type, "player_joined", "Should broadcast player_joined message")

-- Test 4: Make moves
print("\n=== Test 4: Make moves ===")
print("Initial board:")
print_board(state.board)

-- Player 1 makes a move (top-left)
print("\nPlayer 1 (X) moves to position 1")
state = make_move(state, mock_dispatcher, 5, "player1", 1)
last_broadcast = mock_dispatcher:get_last_broadcast()
local move_data = nk.json_decode(last_broadcast.data)
print_board(state.board)
assert_equal(move_data.position, 1, "Should record move at position 1")
assert_equal(move_data.player, "X", "Should be X's move")
assert_equal(move_data.current_player, "O", "Next player should be O")

-- Player 2 makes a move (center)
print("\nPlayer 2 (O) moves to position 5")
state = make_move(state, mock_dispatcher, 6, "player2", 5)
last_broadcast = mock_dispatcher:get_last_broadcast()
move_data = nk.json_decode(last_broadcast.data)
print_board(state.board)
assert_equal(move_data.position, 5, "Should record move at position 5")
assert_equal(move_data.player, "O", "Should be O's move")
assert_equal(move_data.current_player, "X", "Next player should be X")

-- Test 5: Try invalid move (same position)
print("\nTest invalid move (position 1 already taken)")
local prev_state = nk.json_encode(state)
state = make_move(state, mock_dispatcher, 7, "player1", 1)
assert_equal(nk.json_encode(state), prev_state, "State should not change on invalid move")

-- Test 6: Win condition
print("\n=== Test 6: Win condition ===")
print("Completing the game with X winning...")

-- X (player1) takes top-center (position 2)
state = make_move(state, mock_dispatcher, 8, "player1", 2)
-- O (player2) takes top-right (position 3)
state = make_move(state, mock_dispatcher, 9, "player2", 3)
-- X (player1) takes middle-left (position 4)
state = make_move(state, mock_dispatcher, 10, "player1", 4)
-- O (player2) takes middle-right (position 6)
state = make_move(state, mock_dispatcher, 11, "player2", 6)
-- X (player1) takes bottom-left (position 7) - wins diagonally
state = make_move(state, mock_dispatcher, 12, "player1", 7)

last_broadcast = mock_dispatcher:get_last_broadcast()
move_data = nk.json_decode(last_broadcast.data)
print("\nFinal board:")
print_board(state.board)
print("Game over:", move_data.game_over)
print("Winner:", move_data.winner or "None")

assert_equal(move_data.game_over, true, "Game should be over")
assert_equal(move_data.winner, "X", "X should win the game")
assert_equal(#move_data.winning_line, 3, "Should have 3 positions in winning line")

-- Test 7: Player leave
print("\n=== Test 7: Player leave ===")
state = match.match_leave(
    create_mock_context("player1"),
    mock_dispatcher,
    100,
    state,
    {presence1}
)
last_broadcast = mock_dispatcher:get_last_broadcast()
local leave_data = nk.json_decode(last_broadcast.data)
print("Player left message:", leave_data.type)
assert_equal(leave_data.type, "player_left", "Should broadcast player_left message")

-- Test 8: Match termination
print("\n=== Test 8: Match termination ===")
state = match.match_terminate(
    create_mock_context(),
    mock_dispatcher,
    1000,
    state,
    0
)
print("Match terminated successfully")

print("\n‚úÖ All tests passed successfully!")
return "Tests completed"
